{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Framework Documentation This (unnamed) framework is a long list of powerful functions and modules, designed in a very easily accessible way--loading all of the functions is as easy as calling shared() . You can get the files from the uncopylocked game here . Installation If you're using the uncopylocked game as a source, simply copy the contents of game.ReplicatedStorage , game.ServerScriptService , and game.StarterPlayer.StarterPlayerScripts into their respective locations in the place file you'll be using. If you're using scripts from another source, continue reading! To begin, copy the \"Modules\" folder and SharedModuleManager into game.ReplicatedStorage . This will allow the server and the client to access the framework. Activation In order to make the modules easily accessible, they should be embedded into the environment of every script. The cleanest way to do this is to use a script that attaches itself as a metatable to shared , a global that's accessible from all scripts, and then requires every module, adding the results to the script's environment. From there, all a script needs to do to set up the modules is call shared() . This is what the SharedModuleManager module does, as well as sets shared.Ready equal to true once the function is ready to be called. It does, however, still need to be called from whichever sides of the network will be using the framework. There are two scripts which go by the same name of StartShared . One is a server script, and the other is a local script. The server script should go somewhere on the server ( game.ServerScriptService is recommended) and the local script should go somewhere on the client ( game.StarterPlayer.StarterPlayerScripts is recommended). Once this is done, the only effort required to initialize all of these modules is to call shared() at the top of a script. However, be warned: if shared() is called at the very start of a script, the script may occasionally attempt to call shared() before the SharedModuleManager has set up the function to work properly, thus throwing an error. To prevent this from happening, consider waiting until shared.Ready exists, like so: while not shared.Ready do wait() end shared()","title":"Home"},{"location":"#framework-documentation","text":"This (unnamed) framework is a long list of powerful functions and modules, designed in a very easily accessible way--loading all of the functions is as easy as calling shared() . You can get the files from the uncopylocked game here .","title":"Framework Documentation"},{"location":"#installation","text":"If you're using the uncopylocked game as a source, simply copy the contents of game.ReplicatedStorage , game.ServerScriptService , and game.StarterPlayer.StarterPlayerScripts into their respective locations in the place file you'll be using. If you're using scripts from another source, continue reading! To begin, copy the \"Modules\" folder and SharedModuleManager into game.ReplicatedStorage . This will allow the server and the client to access the framework.","title":"Installation"},{"location":"#activation","text":"In order to make the modules easily accessible, they should be embedded into the environment of every script. The cleanest way to do this is to use a script that attaches itself as a metatable to shared , a global that's accessible from all scripts, and then requires every module, adding the results to the script's environment. From there, all a script needs to do to set up the modules is call shared() . This is what the SharedModuleManager module does, as well as sets shared.Ready equal to true once the function is ready to be called. It does, however, still need to be called from whichever sides of the network will be using the framework. There are two scripts which go by the same name of StartShared . One is a server script, and the other is a local script. The server script should go somewhere on the server ( game.ServerScriptService is recommended) and the local script should go somewhere on the client ( game.StarterPlayer.StarterPlayerScripts is recommended). Once this is done, the only effort required to initialize all of these modules is to call shared() at the top of a script. However, be warned: if shared() is called at the very start of a script, the script may occasionally attempt to call shared() before the SharedModuleManager has set up the function to work properly, thus throwing an error. To prevent this from happening, consider waiting until shared.Ready exists, like so: while not shared.Ready do wait() end shared()","title":"Activation"},{"location":"about/","text":"This framework is designed with the intention of making a variety of extra functionality easily accessible. Contributors A list of people to contact for assistance/questions. Name ChipioIndustries","title":"About"},{"location":"about/#contributors","text":"A list of people to contact for assistance/questions. Name ChipioIndustries","title":"Contributors"},{"location":"changelog/","text":"3/25/2020 // v6 // BetterSetCore and DeepCopy New BetterSetCore and DeepCopy functions available! 11/23/2019 // v5 // GetPlayersInRegion3 Fix I thought tableName:insert(value) worked as well as table.insert(tableName,value) . I was wrong, and now GetPlayersInRegion3 should work properly. Added Tags module. 11/21/2019 // v4 // WaitForPath Fix and GetPlayersInRegion3 Fixed major WaitForPath bug that would error if no optional maxWait parameter was provided. New GetPlayersInRegion3 module for easily and efficiently getting players in a certain region. Fixed issue where Enums couldn't be compared properly. Comparisons across the network still don't work properly. 11/10/2019 // v3 // More Reliability, GUI and Data Functions New shared.Ready property to notify scripts of when shared() is ready to be called. Ideal activation within a script has been changed to wait until shared() is ready to be called by looking for shared.Ready . New SetInterfaceVisible module allows for easy setting of a GUI's visibility. New DataRenderer module intelligently converts dictionaries to instances and back. Ideal for player data structures. New Defaultify module applies any specified default values to a specified dictionary. New Menu module allows for easy toggling of a GuiObject / LayerCollector , along with the ability to pass through arguments. New MenuController module handles registering and toggling of Menu s, only allowing one to be visible at a a time and passing through arguments. 11/8/2019 // v2 // Custom Enums and Small Updates Enum module allows for custom enums. Remote module now uses a CollectionService based system instead of being limited to direct children of a specific folder. Installation instructions were simplified, since all of the necessary code already exists in the source place. However, the old instructions have been kept for reference and because they help to describe the functionality of the framework. 11/7/2019 // v1 // Documentation established This exists now, I guess. lol","title":"Changelog"},{"location":"changelog/#3252020-v6-bettersetcore-and-deepcopy","text":"New BetterSetCore and DeepCopy functions available!","title":"3/25/2020 // v6 // BetterSetCore and DeepCopy"},{"location":"changelog/#11232019-v5-getplayersinregion3-fix","text":"I thought tableName:insert(value) worked as well as table.insert(tableName,value) . I was wrong, and now GetPlayersInRegion3 should work properly. Added Tags module.","title":"11/23/2019 // v5 // GetPlayersInRegion3 Fix"},{"location":"changelog/#11212019-v4-waitforpath-fix-and-getplayersinregion3","text":"Fixed major WaitForPath bug that would error if no optional maxWait parameter was provided. New GetPlayersInRegion3 module for easily and efficiently getting players in a certain region. Fixed issue where Enums couldn't be compared properly. Comparisons across the network still don't work properly.","title":"11/21/2019 // v4 // WaitForPath Fix and GetPlayersInRegion3"},{"location":"changelog/#11102019-v3-more-reliability-gui-and-data-functions","text":"New shared.Ready property to notify scripts of when shared() is ready to be called. Ideal activation within a script has been changed to wait until shared() is ready to be called by looking for shared.Ready . New SetInterfaceVisible module allows for easy setting of a GUI's visibility. New DataRenderer module intelligently converts dictionaries to instances and back. Ideal for player data structures. New Defaultify module applies any specified default values to a specified dictionary. New Menu module allows for easy toggling of a GuiObject / LayerCollector , along with the ability to pass through arguments. New MenuController module handles registering and toggling of Menu s, only allowing one to be visible at a a time and passing through arguments.","title":"11/10/2019 // v3 // More Reliability, GUI and Data Functions"},{"location":"changelog/#1182019-v2-custom-enums-and-small-updates","text":"Enum module allows for custom enums. Remote module now uses a CollectionService based system instead of being limited to direct children of a specific folder. Installation instructions were simplified, since all of the necessary code already exists in the source place. However, the old instructions have been kept for reference and because they help to describe the functionality of the framework.","title":"11/8/2019 // v2 // Custom Enums and Small Updates"},{"location":"changelog/#1172019-v1-documentation-established","text":"This exists now, I guess. lol","title":"11/7/2019 // v1 // Documentation established"},{"location":"meme/","text":"","title":"Meme"},{"location":"api/","text":"Select a module to the left to get started. There's nothing here.","title":"Home"},{"location":"api/#select-a-module-to-the-left-to-get-started","text":"There's nothing here.","title":"Select a module to the left to get started."},{"location":"api/betterSetCore/","text":"BetterSetCore is a function that will consistently retry SetCore calls until the method has been registered by the core scripts and the call can go through. If a successful call is unable to be made, a warning with a reason and stack trace will be printed to the output, and the reason will be returned instead of the expected result. Example BetterSetCore(\"ResetButtonCallback\",false) --disables the reset button, no need to wrap in a callback. Parameters Type Name Description string parameterName The name of the parameter to set. Variant value The value to set the parameter to. int [retryDurationLimit=20] The maximum length of time a call can be retried for. Returns Type Description Variant The result of the SetCore call, or an error if the call was never successful.","title":"BetterSetCore"},{"location":"api/betterSetCore/#example","text":"BetterSetCore(\"ResetButtonCallback\",false) --disables the reset button, no need to wrap in a callback.","title":"Example"},{"location":"api/betterSetCore/#parameters","text":"Type Name Description string parameterName The name of the parameter to set. Variant value The value to set the parameter to. int [retryDurationLimit=20] The maximum length of time a call can be retried for.","title":"Parameters"},{"location":"api/betterSetCore/#returns","text":"Type Description Variant The result of the SetCore call, or an error if the call was never successful.","title":"Returns"},{"location":"api/dataRenderer/","text":"DataRenderer is a set of intelligent functions that convert a dictionary to a tree of ValueObject instances and back again. This is incredibly useful for player data management. Compatible Data Types ClassName boolean BoolValue dictionary Folder number IntValue string StringValue Example --when loading local data={ Coins=5; RPName=\"ack\"; Inventory={ Backpack=false; Sword=true; Pet=false; }; } local playerDataFolder=Instance.new({ClassName=\"Folder\";Name=\"PlayerData\";Parent=player}) DataRenderer.ToInstance(playerDataFolder,data) --when saving local playerDataFolder=player:FindFirstChild(\"PlayerData\") if playerDataFolder then local data=DataRenderer.ToDictionary(playerDataFolder) --do stuff with data end Functions Return Function Description void ToInstance(Instance location,dictionary data) Converts the specified data into a tree of ValueObject instances. dictionary ToDictionary(Instance location) Converts the specified location into a dictionary for storage.","title":"DataRenderer"},{"location":"api/dataRenderer/#example","text":"--when loading local data={ Coins=5; RPName=\"ack\"; Inventory={ Backpack=false; Sword=true; Pet=false; }; } local playerDataFolder=Instance.new({ClassName=\"Folder\";Name=\"PlayerData\";Parent=player}) DataRenderer.ToInstance(playerDataFolder,data) --when saving local playerDataFolder=player:FindFirstChild(\"PlayerData\") if playerDataFolder then local data=DataRenderer.ToDictionary(playerDataFolder) --do stuff with data end","title":"Example"},{"location":"api/dataRenderer/#functions","text":"Return Function Description void ToInstance(Instance location,dictionary data) Converts the specified data into a tree of ValueObject instances. dictionary ToDictionary(Instance location) Converts the specified location into a dictionary for storage.","title":"Functions"},{"location":"api/deepCopy/","text":"DeepCopy is a function that will duplicate the provided table/dictionary. Stolen from the devhub . Example local myTable={ \"there is no escape\" } local myTableCopy=DeepCopy(myTable) myTableCopy[1]=\"there is an escape\" print(myTable[1]) --prints \"there is no escape\" Parameters Type Name Description table/dictionary table The table to copy. Returns Type Description table/dictionary A copy of the provided table.","title":"DeepCopy"},{"location":"api/deepCopy/#example","text":"local myTable={ \"there is no escape\" } local myTableCopy=DeepCopy(myTable) myTableCopy[1]=\"there is an escape\" print(myTable[1]) --prints \"there is no escape\"","title":"Example"},{"location":"api/deepCopy/#parameters","text":"Type Name Description table/dictionary table The table to copy.","title":"Parameters"},{"location":"api/deepCopy/#returns","text":"Type Description table/dictionary A copy of the provided table.","title":"Returns"},{"location":"api/defaultify/","text":"Defaultify adds any missing keys into the specified table based on the provided template. If the key is already assigned, the value won't be changed. Example local playerData={} local defaults={Coins=5} playerData=Defaultify(playerData,defaults) Parameters Type Name Description table data The table to defaultify. table defaults The table to draw defaults from. Returns Type Description table The defaultified data table.","title":"Defaultify"},{"location":"api/defaultify/#example","text":"local playerData={} local defaults={Coins=5} playerData=Defaultify(playerData,defaults)","title":"Example"},{"location":"api/defaultify/#parameters","text":"Type Name Description table data The table to defaultify. table defaults The table to draw defaults from.","title":"Parameters"},{"location":"api/defaultify/#returns","text":"Type Description table The defaultified data table.","title":"Returns"},{"location":"api/enum/","text":"The framework automatically appends custom enums to the Enum global. To add a custom enum, simply open the Enum module and add enums to the enum table. At the moment, there are no default custom enums. Warning: Due to Roblox behavior, EnumItems cannot be compared properly when sent across the network. Resort to comparing their Value properties instead: serverEnum.Value==clientEnum.Value Example enum.Example={ Test={ Name=\"Test\"; Value=1; }; }; EnumItem Format Type Name Description string Name The name of the EnumItem. Should match the table's key. number Value The index of the EnumItem.","title":"Enum"},{"location":"api/enum/#example","text":"enum.Example={ Test={ Name=\"Test\"; Value=1; }; };","title":"Example"},{"location":"api/enum/#enumitem-format","text":"Type Name Description string Name The name of the EnumItem. Should match the table's key. number Value The index of the EnumItem.","title":"EnumItem Format"},{"location":"api/errors/","text":"Errors is a dictionary of commonly used errors that can be adapted with string.format() . Example local errorToUse=Errors.BAD_ARG local formatted=errorToUse:format(\"Argument 1\",\"Player\") error(formatted) --errors: \"Argument 1 is not a valid Player\" Errors Name Error BAD_ARG \"%s is not a valid %s\" GONE_ARG \"%s is missing or nil\" BAD_RET \"%s does not return a valid %s\"","title":"Errors"},{"location":"api/errors/#example","text":"local errorToUse=Errors.BAD_ARG local formatted=errorToUse:format(\"Argument 1\",\"Player\") error(formatted) --errors: \"Argument 1 is not a valid Player\"","title":"Example"},{"location":"api/errors/#errors","text":"Name Error BAD_ARG \"%s is not a valid %s\" GONE_ARG \"%s is missing or nil\" BAD_RET \"%s does not return a valid %s\"","title":"Errors"},{"location":"api/event/","text":"An Event is an object used to allow scripts to detect specific changes (or, for lack of a better word, events) between each other. Constructor Return Function Description Event Event.new() Creates a new event object. Functions Return Function Description void Fire(...) Fires the event, passing through all of the arguments. EventConnection Connect(function functionToFire) Creates a connection between the given function and the event. void Wait() Yields until the event is fired. Does not return any arguments.","title":"Event"},{"location":"api/event/#constructor","text":"Return Function Description Event Event.new() Creates a new event object.","title":"Constructor"},{"location":"api/event/#functions","text":"Return Function Description void Fire(...) Fires the event, passing through all of the arguments. EventConnection Connect(function functionToFire) Creates a connection between the given function and the event. void Wait() Yields until the event is fired. Does not return any arguments.","title":"Functions"},{"location":"api/eventConnection/","text":"An EventConnection is a simple object that mimics the behavior of an RBXScriptConnection by allowing the player to disconnect it if needed. Constructor Return Function Description Event EventConnection.new(Event event, string functionID) Creates a new connection to the event with the given ID. Properties Type Name Description bool Connected Whether or not the connection is still active. Functions Return Function Description void Disconnect() Erases the connection.","title":"EventConnection"},{"location":"api/eventConnection/#constructor","text":"Return Function Description Event EventConnection.new(Event event, string functionID) Creates a new connection to the event with the given ID.","title":"Constructor"},{"location":"api/eventConnection/#properties","text":"Type Name Description bool Connected Whether or not the connection is still active.","title":"Properties"},{"location":"api/eventConnection/#functions","text":"Return Function Description void Disconnect() Erases the connection.","title":"Functions"},{"location":"api/find/","text":"Find is a simple function that returns the specified value's index within a table. This is useful for removing items when you don't know the index. This function will soon be obsolete once the introduction of table.find is pushed, but it's already been two weeks... I wouldn't hold my breath. Also, this supports arrays and dictionaries, while the official version only supports arrays. Example local newTable={workspace,game.Players,\"hi\",12345} local toFind=\"hi\" local index=Find(newTable,\"hi\") --result is 3 Parameters Type Name Description array/dictionary tableToSearch The table to search through. Variant valueToFind The value to find within the table. Returns Type Description number/string The index of the value within the table.","title":"Find"},{"location":"api/find/#example","text":"local newTable={workspace,game.Players,\"hi\",12345} local toFind=\"hi\" local index=Find(newTable,\"hi\") --result is 3","title":"Example"},{"location":"api/find/#parameters","text":"Type Name Description array/dictionary tableToSearch The table to search through. Variant valueToFind The value to find within the table.","title":"Parameters"},{"location":"api/find/#returns","text":"Type Description number/string The index of the value within the table.","title":"Returns"},{"location":"api/formatImageAddress/","text":"FormatImageAddress is a function that will convert an asset ID into a URL, or simply pass through a URL if it's already correctly formatted. Example local formatted=FormatImageAddress(12345678) --returns string \"rbxassetid://12345678\" Parameters Type Name Description string/number incompleteAddress The address to format. Returns Type Description string The formatted image address.","title":"FormatImageAddress"},{"location":"api/formatImageAddress/#example","text":"local formatted=FormatImageAddress(12345678) --returns string \"rbxassetid://12345678\"","title":"Example"},{"location":"api/formatImageAddress/#parameters","text":"Type Name Description string/number incompleteAddress The address to format.","title":"Parameters"},{"location":"api/formatImageAddress/#returns","text":"Type Description string The formatted image address.","title":"Returns"},{"location":"api/gamepass/","text":"Gamepass is a wrapper for UserOwnsGamepassAsync() that adds additional functionality, including: support for finding a player's pass ownership using their user ID or the Player object itself; a smart cache that automatically updates when a gamepass purchase is made, whereas the classic system simply caches the first request permanently; events for when a specific game pass is purchased. Example local gamepassID=1234 local userID=246810 local hasGamePass=Gamepass.Has(userID,gamepassID) --returns true/false local passPurchasedEvent=Gamepass.GetpassPurchasedEvent(gamepassID) function onPassPurchased(player) print(player.Name..\" purchased the gamepass!\") end passPurchasedEvent:Connect(onPassPurchased) Functions Return Function Description bool Has(number userID, number passID) Returns whether or not the given user owns the given gamepass. bool Has(Player player, number passID) Returns whether or not the given user owns the given gamepass. Event GetPassPurchasedEvent(number passID) Returns an event that fires when the gamepass is purchased. The purchasing player object is passed as an argument.","title":"Gamepass"},{"location":"api/gamepass/#example","text":"local gamepassID=1234 local userID=246810 local hasGamePass=Gamepass.Has(userID,gamepassID) --returns true/false local passPurchasedEvent=Gamepass.GetpassPurchasedEvent(gamepassID) function onPassPurchased(player) print(player.Name..\" purchased the gamepass!\") end passPurchasedEvent:Connect(onPassPurchased)","title":"Example"},{"location":"api/gamepass/#functions","text":"Return Function Description bool Has(number userID, number passID) Returns whether or not the given user owns the given gamepass. bool Has(Player player, number passID) Returns whether or not the given user owns the given gamepass. Event GetPassPurchasedEvent(number passID) Returns an event that fires when the gamepass is purchased. The purchasing player object is passed as an argument.","title":"Functions"},{"location":"api/getClosest/","text":"GetClosest has two very similar functions that are used to choose from a list of numbers the closest number to the provided goal. Depending on the function used, the script will find the closest number that is under or the closest number that is over the limit. Really, the only use case for this that comes to mind is a developer product system that prompts the player to buy the minimum amount of currency required to complete a purchase. Example local neededCoins=1234 local productOptions={100,250,500,1000,2500,5000,10000,25000,50000} local amountToPrompt=GetClosest.Over(neededCoins,productOptions) print(amountToPrompt) --will print 2500 Functions Return Function Description number Over(number limit,table numbers) Returns the smallest number over the limit. number Under(number limit,table numbers) Returns the largest number under the limit. Notes I'm considering creating some variation of this (or simply editing the existing one) that returns the index, not the actual number. It fits the developer product use case much better, where the script would then just need to find the associated product ID anyway.","title":"GetClosest"},{"location":"api/getClosest/#example","text":"local neededCoins=1234 local productOptions={100,250,500,1000,2500,5000,10000,25000,50000} local amountToPrompt=GetClosest.Over(neededCoins,productOptions) print(amountToPrompt) --will print 2500","title":"Example"},{"location":"api/getClosest/#functions","text":"Return Function Description number Over(number limit,table numbers) Returns the smallest number over the limit. number Under(number limit,table numbers) Returns the largest number under the limit.","title":"Functions"},{"location":"api/getClosest/#notes","text":"I'm considering creating some variation of this (or simply editing the existing one) that returns the index, not the actual number. It fits the developer product use case much better, where the script would then just need to find the associated product ID anyway.","title":"Notes"},{"location":"api/getPlayersInRegion3/","text":"GetPlayersInRegion3 is a quick, efficient tool for getting a list of players whose HumanoidRootPart s are currently within a specified Region3. This is ideal for things like zone loading and goal areas. Example local r3=Region3.new(Vector3.new(-10,10,-10),Vector3.new(10,0,10)) local players=GetPlayersInRegion3(r3) Parameters Type Name Description Region3 region The Region3 to find all players within. Returns Type Description table A list of players who reside within the specified region.","title":"GetPlayersInRegion3"},{"location":"api/getPlayersInRegion3/#example","text":"local r3=Region3.new(Vector3.new(-10,10,-10),Vector3.new(10,0,10)) local players=GetPlayersInRegion3(r3)","title":"Example"},{"location":"api/getPlayersInRegion3/#parameters","text":"Type Name Description Region3 region The Region3 to find all players within.","title":"Parameters"},{"location":"api/getPlayersInRegion3/#returns","text":"Type Description table A list of players who reside within the specified region.","title":"Returns"},{"location":"api/getProductInfo/","text":"GetProductInfo wraps MarketplaceService.GetProductInfo in a cache to prevent using too many requests. If a player is passed when getting a gamepass's information, whether or not the player owns the gamepass will be included in the dictionary as well. Example local passID=1234 local player=game.Players.LocalPlayer local info=GetProductInfo(passID,Enum.InfoType.GamePass,player) print(info.Name,info.IsOwned) --prints the name of the game pass and whether or not the player owns it Parameters Type Name Description number assetID The ID of the asset to get the information of. InfoType infoType The type of asset to get the info of. Player [player] The player to check ownership info of. Returns Type Name Description string Name The name shown on the asset's page string Description The description as shown on the asset's page; can be nil if blank number PriceInRobux The cost of purchasing the asset using Robux timestamp Created Timestamp of when the asset was created, e.g. 2018-08-01T17:55:11.98Z timestamp Updated Timestamp of when the asset was last updated by its creator, e.g. 2018-08-01T17:55:11.98Z number ContentRatingTypeId Indicates whether the item is marked as 13+ in catalog number MinimumMembershipLevel The minimum subscription level necessary to purchase the item boolean IsPublicDomain Describes whether the asset can be taken for free - - - Creator Creator A table of information describing the creator of the asset (see following lines) string Creator.CreatorType Either User or Group number Creator.CreatorTargetId The ID of the creator user or group string Creator.Name The name/username of the creator number Creator.Id (Use CreatorTargetId instead) - - - number AssetId If InfoType was Asset, this is the ID of the given asset. number AssetTypeId The type of asset (e.g. place, model, shirt)* boolean IsForSale Describes whether the asset is purchasable boolean IsLimited Describes whether the asset is a \"limited item\" that is no longer (if ever) sold boolean IsLimitedUnique Describes whether the asset is a \"limited unique\" (\"Limited U\") item that only has a fixed number sold boolean IsNew Describes whether the asset is marked as \"new\" in the catalog number Remaining The remaining number of items a limited unique item may be sold number Sales The number of items the asset has been sold - - - number ProductId If the InfoType was Product, this is the product ID number IconImageAssetId For developer products and gamepasses, this is the asset ID of the product's icon (or 0 if the product does not have one) - - - boolean IsOwned Whether or not the specified player (if any) owns the item if it's a gamepass.","title":"GetProductInfo"},{"location":"api/getProductInfo/#example","text":"local passID=1234 local player=game.Players.LocalPlayer local info=GetProductInfo(passID,Enum.InfoType.GamePass,player) print(info.Name,info.IsOwned) --prints the name of the game pass and whether or not the player owns it","title":"Example"},{"location":"api/getProductInfo/#parameters","text":"Type Name Description number assetID The ID of the asset to get the information of. InfoType infoType The type of asset to get the info of. Player [player] The player to check ownership info of.","title":"Parameters"},{"location":"api/getProductInfo/#returns","text":"Type Name Description string Name The name shown on the asset's page string Description The description as shown on the asset's page; can be nil if blank number PriceInRobux The cost of purchasing the asset using Robux timestamp Created Timestamp of when the asset was created, e.g. 2018-08-01T17:55:11.98Z timestamp Updated Timestamp of when the asset was last updated by its creator, e.g. 2018-08-01T17:55:11.98Z number ContentRatingTypeId Indicates whether the item is marked as 13+ in catalog number MinimumMembershipLevel The minimum subscription level necessary to purchase the item boolean IsPublicDomain Describes whether the asset can be taken for free - - - Creator Creator A table of information describing the creator of the asset (see following lines) string Creator.CreatorType Either User or Group number Creator.CreatorTargetId The ID of the creator user or group string Creator.Name The name/username of the creator number Creator.Id (Use CreatorTargetId instead) - - - number AssetId If InfoType was Asset, this is the ID of the given asset. number AssetTypeId The type of asset (e.g. place, model, shirt)* boolean IsForSale Describes whether the asset is purchasable boolean IsLimited Describes whether the asset is a \"limited item\" that is no longer (if ever) sold boolean IsLimitedUnique Describes whether the asset is a \"limited unique\" (\"Limited U\") item that only has a fixed number sold boolean IsNew Describes whether the asset is marked as \"new\" in the catalog number Remaining The remaining number of items a limited unique item may be sold number Sales The number of items the asset has been sold - - - number ProductId If the InfoType was Product, this is the product ID number IconImageAssetId For developer products and gamepasses, this is the asset ID of the product's icon (or 0 if the product does not have one) - - - boolean IsOwned Whether or not the specified player (if any) owns the item if it's a gamepass.","title":"Returns"},{"location":"api/instance/","text":"The Instance global has been modified to support a unique creation method that accepts a table of properties, along with specific additions to always assign the Parent last for performance reasons. Simply passing in a classname will automatically use the classic constructor. Constructor Return Function Description Instance Instance.new(Dictionary properties) Creates a new instance with the listed properties. A ClassName must be specified. Instance Instance.new(string className[, Instance parent]) Creates a new instance using the provided ClassName , applying the provided Parent if provided. Example local newInstance=Instance.new({ ClassName=\"Part\"; CFrame=CFrame.new(0,10,0); BrickColor=BrickColor.new(\"Really red\"); Parent=workspace; }) -- OR local oldInstance=Instance.new(\"Part\",workspace)","title":"Instance"},{"location":"api/instance/#constructor","text":"Return Function Description Instance Instance.new(Dictionary properties) Creates a new instance with the listed properties. A ClassName must be specified. Instance Instance.new(string className[, Instance parent]) Creates a new instance using the provided ClassName , applying the provided Parent if provided.","title":"Constructor"},{"location":"api/instance/#example","text":"local newInstance=Instance.new({ ClassName=\"Part\"; CFrame=CFrame.new(0,10,0); BrickColor=BrickColor.new(\"Really red\"); Parent=workspace; }) -- OR local oldInstance=Instance.new(\"Part\",workspace)","title":"Example"},{"location":"api/leakyBucket/","text":"A LeakyBucket is a class containing a number that slowly decreases to 0. It is useful for things like rate limits. Constructor Return Function Description LeakyBucket LeakyBucket.new([number start=0,number rate=1]) Creates a new LeakyBucket starting at the specified start point, decreasing by 1 every time rate passes in seconds. Properties Type Name Description number Bucket The current amount in the bucket. number Rate How often the bucket is decreased. Functions Return Function Description void Add([number amount=1]) Adds the specified amount to the bucket. void Clear([number to=0]) Empties the bucket to the specified level. void Destroy() Destroys the bucket.","title":"LeakyBucket"},{"location":"api/leakyBucket/#constructor","text":"Return Function Description LeakyBucket LeakyBucket.new([number start=0,number rate=1]) Creates a new LeakyBucket starting at the specified start point, decreasing by 1 every time rate passes in seconds.","title":"Constructor"},{"location":"api/leakyBucket/#properties","text":"Type Name Description number Bucket The current amount in the bucket. number Rate How often the bucket is decreased.","title":"Properties"},{"location":"api/leakyBucket/#functions","text":"Return Function Description void Add([number amount=1]) Adds the specified amount to the bucket. void Clear([number to=0]) Empties the bucket to the specified level. void Destroy() Destroys the bucket.","title":"Functions"},{"location":"api/menu/","text":"A Menu is a simple object for managing a LayerCollector / GuiObject 's visibility and passing through arguments. Constructor Return Function Description Menu Menu.new(GuiObject/LayerCollector gui) Creates a new menu object. Properties Type Name Description LayerCollector\\GuiObject GuiObject The item being controlled by the Menu. Functions Return Function Description void SetVisibility(bool to,...) Changes the item's visibility, passing through any extra arguments to the event. Events Event Description VisibilityChanged(bool to,...) Fires when the item's visibility has been called to change, passing through any extra arguments.","title":"Menu"},{"location":"api/menu/#constructor","text":"Return Function Description Menu Menu.new(GuiObject/LayerCollector gui) Creates a new menu object.","title":"Constructor"},{"location":"api/menu/#properties","text":"Type Name Description LayerCollector\\GuiObject GuiObject The item being controlled by the Menu.","title":"Properties"},{"location":"api/menu/#functions","text":"Return Function Description void SetVisibility(bool to,...) Changes the item's visibility, passing through any extra arguments to the event.","title":"Functions"},{"location":"api/menu/#events","text":"Event Description VisibilityChanged(bool to,...) Fires when the item's visibility has been called to change, passing through any extra arguments.","title":"Events"},{"location":"api/menuController/","text":"A MenuController is a class for managing a set of Menu s, only allowing one to be visible at a time. Constructor Return Function Description MenuController MenuController.new(dictionary menus) Creates a new MenuController object. Properties Type Name Description bool Exists Whether or not the MenuController still exists. Functions Return Function Description void AddMenu(GuiObject/LayerCollector menu,string title) Registers a new menu to be activated with the provided title. void ClearMenu() Clears the current menu if there is one. void SetMenu(string title,...) Set the currently enabled menu to whichever one matched the specified title. void GetMenu() Get the currently enabled Menu object. void Destroy() Destroys the MenuController.","title":"MenuController"},{"location":"api/menuController/#constructor","text":"Return Function Description MenuController MenuController.new(dictionary menus) Creates a new MenuController object.","title":"Constructor"},{"location":"api/menuController/#properties","text":"Type Name Description bool Exists Whether or not the MenuController still exists.","title":"Properties"},{"location":"api/menuController/#functions","text":"Return Function Description void AddMenu(GuiObject/LayerCollector menu,string title) Registers a new menu to be activated with the provided title. void ClearMenu() Clears the current menu if there is one. void SetMenu(string title,...) Set the currently enabled menu to whichever one matched the specified title. void GetMenu() Get the currently enabled Menu object. void Destroy() Destroys the MenuController.","title":"Functions"},{"location":"api/prettyNumber/","text":"PrettyNumber is a function that will format a number to include commas separating the thousands. It's definitely just stolen from the internet . Example local formatted=PrettyNumber(12000000) --returns string \"12,000,000\" Parameters Type Name Description string/number number The number to add commas to. Returns Type Description string The formatted number.","title":"PrettyNumber"},{"location":"api/prettyNumber/#example","text":"local formatted=PrettyNumber(12000000) --returns string \"12,000,000\"","title":"Example"},{"location":"api/prettyNumber/#parameters","text":"Type Name Description string/number number The number to add commas to.","title":"Parameters"},{"location":"api/prettyNumber/#returns","text":"Type Description string The formatted number.","title":"Returns"},{"location":"api/products/","text":"Products is a dictionary of various game passes and developer products for the game to use depending on the game's place ID. Configuration The script contains a dictionary named Places which holds a place ID. The name accompanying the place ID should match the name of the dictionary within the Products dictionary. By default, two places are supported (\"Main\" and \"Dev\"), but it is easy to add more. If the current place's ID is not specified anywhere, the module will return all products across all places.","title":"Products"},{"location":"api/products/#configuration","text":"The script contains a dictionary named Places which holds a place ID. The name accompanying the place ID should match the name of the dictionary within the Products dictionary. By default, two places are supported (\"Main\" and \"Dev\"), but it is easy to add more. If the current place's ID is not specified anywhere, the module will return all products across all places.","title":"Configuration"},{"location":"api/promotedAccounts/","text":"PromotedAccounts is a dictionary of various social media accounts to call players to check out or follow. Sites Site Name Format Twitter \"@NAME\" YouTube \"NAME\" Roblox \"NAME\"","title":"PromotedAccounts"},{"location":"api/promotedAccounts/#sites","text":"Site Name Format Twitter \"@NAME\" YouTube \"NAME\" Roblox \"NAME\"","title":"Sites"},{"location":"api/remote/","text":"Remote is a function used to easily get a remote by the specified name. The script automatically detects all remotes by finding instances with a specific tag (by default, \"Remote\", but can be changed within the script). The framework has a specific organization for remotes where a \"remote\" is actually a folder with the remote name containing any combination of the four remote types ( BindableFunction , BindableEvent , RemoteFunction , RemoteEvent ). Example local myRemote=Remote(\"MyRemote\") --returns the folder by the name of \"MyRemote\" Parameters Type Name Description string remoteName The name of the remote to return. Returns Type Description Instance The remote with the specified name, or nil if there is no remote by that name.","title":"Remote"},{"location":"api/remote/#example","text":"local myRemote=Remote(\"MyRemote\") --returns the folder by the name of \"MyRemote\"","title":"Example"},{"location":"api/remote/#parameters","text":"Type Name Description string remoteName The name of the remote to return.","title":"Parameters"},{"location":"api/remote/#returns","text":"Type Description Instance The remote with the specified name, or nil if there is no remote by that name.","title":"Returns"},{"location":"api/require/","text":"Require is an advanced version of require which accepts a module name instead of a path. If the argument provided is not a string, it will instead treat it as a path and return the result of the regular require function. Example local myModule=Require(\"MyModule\") Parameters Type Name Description string moduleName The name of the module to require. Returns Type Description Variant The result of the module required.","title":"Require"},{"location":"api/require/#example","text":"local myModule=Require(\"MyModule\")","title":"Example"},{"location":"api/require/#parameters","text":"Type Name Description string moduleName The name of the module to require.","title":"Parameters"},{"location":"api/require/#returns","text":"Type Description Variant The result of the module required.","title":"Returns"},{"location":"api/round/","text":"Round is a function that will round the provided number to the nearest multiple (to) or nearest whole number. Example local toThousands=Round(12345678.9,1000) --returns number 12346000 local toWhole=Round(5.2945) --returns number 5 Parameters Type Name Description number number The number to round. number [denominator=1] The multiple to round to. Returns Type Description number The rounded number.","title":"Round"},{"location":"api/round/#example","text":"local toThousands=Round(12345678.9,1000) --returns number 12346000 local toWhole=Round(5.2945) --returns number 5","title":"Example"},{"location":"api/round/#parameters","text":"Type Name Description number number The number to round. number [denominator=1] The multiple to round to.","title":"Parameters"},{"location":"api/round/#returns","text":"Type Description number The rounded number.","title":"Returns"},{"location":"api/search/","text":"Search is a function that searches the given path for the first instance with properties matching all of the criteria specified, or nil if no matches can be found. Example local requirements={Name=\"MyThing\",ClassName=\"Part\"} local part=Search(workspace,requirements) --returns the first part in Workspace named \"MyThing\" Parameters Type Name Description Instance path The path to search the contents of. Dictionary parameters The property values to check. Returns Type Description Instance The result of the search, or nil if unsuccessful.","title":"Search"},{"location":"api/search/#example","text":"local requirements={Name=\"MyThing\",ClassName=\"Part\"} local part=Search(workspace,requirements) --returns the first part in Workspace named \"MyThing\"","title":"Example"},{"location":"api/search/#parameters","text":"Type Name Description Instance path The path to search the contents of. Dictionary parameters The property values to check.","title":"Parameters"},{"location":"api/search/#returns","text":"Type Description Instance The result of the search, or nil if unsuccessful.","title":"Returns"},{"location":"api/setInterfaceVisible/","text":"SetInterfaceVisible is a function that automatically sets a GUI's visibility, whether it's a GuiObject or a LayerCollector . That's all. Example local plr=game.Players.LocalPlayer local gui=WaitForPath(plr,\"PlayerGui.ScreenGui\") SetInterfaceVisible(gui,true) Parameters Type Name Description GuiObject/LayerCollector gui The GUI to set the visibility of. bool enabled Whether or not the specified gui should be enabled.","title":"SetInterfaceVisible"},{"location":"api/setInterfaceVisible/#example","text":"local plr=game.Players.LocalPlayer local gui=WaitForPath(plr,\"PlayerGui.ScreenGui\") SetInterfaceVisible(gui,true)","title":"Example"},{"location":"api/setInterfaceVisible/#parameters","text":"Type Name Description GuiObject/LayerCollector gui The GUI to set the visibility of. bool enabled Whether or not the specified gui should be enabled.","title":"Parameters"},{"location":"api/tags/","text":"Used purely to keep a list of CollectionService tags. Since entries are constants, the names should be capitalized and words should be separated with underscores, i.e. TAG_NAME . Example Tags={ VISUAL_MARKER=\"MARKER_PART\" }","title":"Tags"},{"location":"api/tags/#example","text":"Tags={ VISUAL_MARKER=\"MARKER_PART\" }","title":"Example"},{"location":"api/waitForPath/","text":"WaitForPath is a function that eliminates the need for long strings of WaitForChild by simply accepting a starting point and a path. Example local player=game.Players.LocalPlayer local gui=WaitForPath(player,\"PlayerGui.ScreenGui.Frame.TextButton\") Parameters Type Name Description Instance target The point to start waiting from. string path The path to wait for, with periods (.) separating each instance name. number [maxWait] The maximum amount of time to wait for the items to load. Returns Type Description Instance The result of the waiting period, or nil if unsuccessful.","title":"WaitForPath"},{"location":"api/waitForPath/#example","text":"local player=game.Players.LocalPlayer local gui=WaitForPath(player,\"PlayerGui.ScreenGui.Frame.TextButton\")","title":"Example"},{"location":"api/waitForPath/#parameters","text":"Type Name Description Instance target The point to start waiting from. string path The path to wait for, with periods (.) separating each instance name. number [maxWait] The maximum amount of time to wait for the items to load.","title":"Parameters"},{"location":"api/waitForPath/#returns","text":"Type Description Instance The result of the waiting period, or nil if unsuccessful.","title":"Returns"}]}