{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Framework Documentation This (unnamed) framework is a long list of powerful functions and modules, designed in a very easily accessible way--loading all of the functions is as easy as calling shared() . You can get the files from the uncopylocked game here . Installation To begin, copy the \"Modules\" folder and SharedModuleManager into game.ReplicatedStorage . This will allow the server and the client to access the framework. Activation In order to make the modules easily accessible, they should be embedded into the environment of every script. The cleanest way to do this is to use a script that attaches itself as a metatable to shared , a global that's accessible from all scripts, and then requires every module, adding the results to the script's environment. From there, all a script needs to do to set up the modules is call shared() . This is what the SharedModuleManager module does. It does, however, still need to be called from whichever sides of the network will be using the framework. There are two scripts which go by the same name of StartShared . One is a server script, and the other is a local script. The server script should go somewhere on the server ( game.ServerScriptService is recommended) and the local script should go somewhere on the client ( game.StarterPlayer.StarterPlayerScripts is recommended). Once this is done, the only effort required to initialize all of these modules is to call shared() at the top of a script.","title":"Home"},{"location":"#framework-documentation","text":"This (unnamed) framework is a long list of powerful functions and modules, designed in a very easily accessible way--loading all of the functions is as easy as calling shared() . You can get the files from the uncopylocked game here .","title":"Framework Documentation"},{"location":"#installation","text":"To begin, copy the \"Modules\" folder and SharedModuleManager into game.ReplicatedStorage . This will allow the server and the client to access the framework.","title":"Installation"},{"location":"#activation","text":"In order to make the modules easily accessible, they should be embedded into the environment of every script. The cleanest way to do this is to use a script that attaches itself as a metatable to shared , a global that's accessible from all scripts, and then requires every module, adding the results to the script's environment. From there, all a script needs to do to set up the modules is call shared() . This is what the SharedModuleManager module does. It does, however, still need to be called from whichever sides of the network will be using the framework. There are two scripts which go by the same name of StartShared . One is a server script, and the other is a local script. The server script should go somewhere on the server ( game.ServerScriptService is recommended) and the local script should go somewhere on the client ( game.StarterPlayer.StarterPlayerScripts is recommended). Once this is done, the only effort required to initialize all of these modules is to call shared() at the top of a script.","title":"Activation"},{"location":"about/","text":"This framework is designed with the intention of making a variety of extra functionality easily accessible. Contributors A list of people to contact for assistance/questions. Name ChipioIndustries","title":"About"},{"location":"about/#contributors","text":"A list of people to contact for assistance/questions. Name ChipioIndustries","title":"Contributors"},{"location":"changelog/","text":"11/7/2019 // v1 // Documentation established This exists now, I guess. lol","title":"Changelog"},{"location":"changelog/#1172019-v1-documentation-established","text":"This exists now, I guess. lol","title":"11/7/2019 // v1 // Documentation established"},{"location":"meme/","text":"","title":"Meme"},{"location":"api/","text":"Select a module to the left to get started. There's nothing here.","title":"Home"},{"location":"api/#select-a-module-to-the-left-to-get-started","text":"There's nothing here.","title":"Select a module to the left to get started."},{"location":"api/errors/","text":"Errors is a dictionary of commonly used errors that can be adapted with string.format() . Example local errorToUse=Errors.BAD_ARG local formatted=errorToUse:format(\"Argument 1\",\"Player\") error(formatted) --errors: \"Argument 1 is not a valid Player\" Errors Name Error BAD_ARG \"%s is not a valid %s\" GONE_ARG \"%s is missing or nil\" BAD_RET \"%s does not return a valid %s\"","title":"Errors"},{"location":"api/errors/#example","text":"local errorToUse=Errors.BAD_ARG local formatted=errorToUse:format(\"Argument 1\",\"Player\") error(formatted) --errors: \"Argument 1 is not a valid Player\"","title":"Example"},{"location":"api/errors/#errors","text":"Name Error BAD_ARG \"%s is not a valid %s\" GONE_ARG \"%s is missing or nil\" BAD_RET \"%s does not return a valid %s\"","title":"Errors"},{"location":"api/event/","text":"An Event is an object used to allow scripts to detect specific changes (or, for lack of a better word, events) between each other. Constructor Return Function Description Event Event.new() Creates a new event object. Functions Return Function Description void Fire(...) Fires the event, passing through all of the arguments. EventConnection Connect(function functionToFire) Creates a connection between the given function and the event. void Wait() Yields until the event is fired. Does not return any arguments.","title":"Event"},{"location":"api/event/#constructor","text":"Return Function Description Event Event.new() Creates a new event object.","title":"Constructor"},{"location":"api/event/#functions","text":"Return Function Description void Fire(...) Fires the event, passing through all of the arguments. EventConnection Connect(function functionToFire) Creates a connection between the given function and the event. void Wait() Yields until the event is fired. Does not return any arguments.","title":"Functions"},{"location":"api/eventConnection/","text":"An EventConnection is a simple object that mimics the behavior of an RBXScriptConnection by allowing the player to disconnect it if needed. Constructor Return Function Description Event EventConnection.new(Event event, string functionID) Creates a new connection to the event with the given ID. Properties Type Name Description bool Connected Whether or not the connection is still active. Functions Return Function Description void Disconnect() Erases the connection.","title":"EventConnection"},{"location":"api/eventConnection/#constructor","text":"Return Function Description Event EventConnection.new(Event event, string functionID) Creates a new connection to the event with the given ID.","title":"Constructor"},{"location":"api/eventConnection/#properties","text":"Type Name Description bool Connected Whether or not the connection is still active.","title":"Properties"},{"location":"api/eventConnection/#functions","text":"Return Function Description void Disconnect() Erases the connection.","title":"Functions"},{"location":"api/find/","text":"Find is a simple function that returns the specified value's index within a table. This is useful for removing items when you don't know the index. This function will soon be obsolete once the introduction of table.find is pushed, but it's already been two weeks... I wouldn't hold my breath. Also, this supports arrays and dictionaries, while the official version only supports arrays. Example local newTable={workspace,game.Players,\"hi\",12345} local toFind=\"hi\" local index=Find(newTable,\"hi\") --result is 3 Parameters Type Name Description array/dictionary tableToSearch The table to search through. Variant valueToFind The value to find within the table. Returns Type Description number/string The index of the value within the table.","title":"Find"},{"location":"api/find/#example","text":"local newTable={workspace,game.Players,\"hi\",12345} local toFind=\"hi\" local index=Find(newTable,\"hi\") --result is 3","title":"Example"},{"location":"api/find/#parameters","text":"Type Name Description array/dictionary tableToSearch The table to search through. Variant valueToFind The value to find within the table.","title":"Parameters"},{"location":"api/find/#returns","text":"Type Description number/string The index of the value within the table.","title":"Returns"},{"location":"api/formatImageAddress/","text":"FormatImageAddress is a function that will convert an asset ID into a URL, or simply pass through a URL if it's already correctly formatted. Example local formatted=FormatImageAddress(12345678) --returns string \"rbxassetid://12345678\" Parameters Type Name Description string/number incompleteAddress The address to format. Returns Type Description string The formatted image address.","title":"FormatImageAddress"},{"location":"api/formatImageAddress/#example","text":"local formatted=FormatImageAddress(12345678) --returns string \"rbxassetid://12345678\"","title":"Example"},{"location":"api/formatImageAddress/#parameters","text":"Type Name Description string/number incompleteAddress The address to format.","title":"Parameters"},{"location":"api/formatImageAddress/#returns","text":"Type Description string The formatted image address.","title":"Returns"},{"location":"api/gamepass/","text":"Gamepass is a wrapper for UserOwnsGamepassAsync() that adds additional functionality, including: support for finding a player's pass ownership using their user ID or the Player object itself; a smart cache that automatically updates when a gamepass purchase is made, whereas the classic system simply caches the first request permanently; events for when a specific game pass is purchased. Example local gamepassID=1234 local userID=246810 local hasGamePass=Gamepass.Has(userID,gamepassID) --returns true/false local passPurchasedEvent=Gamepass.GetpassPurchasedEvent(gamepassID) function onPassPurchased(player) print(player.Name..\" purchased the gamepass!\") end passPurchasedEvent:Connect(onPassPurchased) Functions Return Function Description bool Has(number userID, number passID) Returns whether or not the given user owns the given gamepass. bool Has(Player player, number passID) Returns whether or not the given user owns the given gamepass. Event GetPassPurchasedEvent(number passID) Returns an event that fires when the gamepass is purchased. The purchasing player object is passed as an argument.","title":"Gamepass"},{"location":"api/gamepass/#example","text":"local gamepassID=1234 local userID=246810 local hasGamePass=Gamepass.Has(userID,gamepassID) --returns true/false local passPurchasedEvent=Gamepass.GetpassPurchasedEvent(gamepassID) function onPassPurchased(player) print(player.Name..\" purchased the gamepass!\") end passPurchasedEvent:Connect(onPassPurchased)","title":"Example"},{"location":"api/gamepass/#functions","text":"Return Function Description bool Has(number userID, number passID) Returns whether or not the given user owns the given gamepass. bool Has(Player player, number passID) Returns whether or not the given user owns the given gamepass. Event GetPassPurchasedEvent(number passID) Returns an event that fires when the gamepass is purchased. The purchasing player object is passed as an argument.","title":"Functions"},{"location":"api/getClosest/","text":"GetClosest has two very similar functions that are used to choose from a list of numbers the closest number to the provided goal. Depending on the function used, the script will find the closest number that is under or the closest number that is over the limit. Really, the only use case for this that comes to mind is a developer product system that prompts the player to buy the minimum amount of currency required to complete a purchase. Example local neededCoins=1234 local productOptions={100,250,500,1000,2500,5000,10000,25000,50000} local amountToPrompt=GetClosest.Over(neededCoins,productOptions) print(amountToPrompt) --will print 2500 Functions Return Function Description number Over(number limit,table numbers) Returns the smallest number over the limit. number Under(number limit,table numbers) Returns the largest number under the limit. Notes I'm considering creating some variation of this (or simply editing the existing one) that returns the index, not the actual number. It fits the developer product use case much better, where the script would then just need to find the associated product ID anyway.","title":"GetClosest"},{"location":"api/getClosest/#example","text":"local neededCoins=1234 local productOptions={100,250,500,1000,2500,5000,10000,25000,50000} local amountToPrompt=GetClosest.Over(neededCoins,productOptions) print(amountToPrompt) --will print 2500","title":"Example"},{"location":"api/getClosest/#functions","text":"Return Function Description number Over(number limit,table numbers) Returns the smallest number over the limit. number Under(number limit,table numbers) Returns the largest number under the limit.","title":"Functions"},{"location":"api/getClosest/#notes","text":"I'm considering creating some variation of this (or simply editing the existing one) that returns the index, not the actual number. It fits the developer product use case much better, where the script would then just need to find the associated product ID anyway.","title":"Notes"},{"location":"api/getProductInfo/","text":"GetProductInfo wraps MarketplaceService.GetProductInfo in a cache to prevent using too many requests. If a player is passed when getting a gamepass's information, whether or not the player owns the gamepass will be included in the dictionary as well. Example local passID=1234 local player=game.Players.LocalPlayer local info=GetProductInfo(passID,Enum.InfoType.GamePass,player) print(info.Name,info.IsOwned) --prints the name of the game pass and whether or not the player owns it Parameters Type Name Description number assetID The ID of the asset to get the information of. InfoType infoType The type of asset to get the info of. Player [player] The player to check ownership info of. Returns Type Name Description string Name The name shown on the asset's page string Description The description as shown on the asset's page; can be nil if blank number PriceInRobux The cost of purchasing the asset using Robux timestamp Created Timestamp of when the asset was created, e.g. 2018-08-01T17:55:11.98Z timestamp Updated Timestamp of when the asset was last updated by its creator, e.g. 2018-08-01T17:55:11.98Z number ContentRatingTypeId Indicates whether the item is marked as 13+ in catalog number MinimumMembershipLevel The minimum subscription level necessary to purchase the item boolean IsPublicDomain Describes whether the asset can be taken for free - - - Creator Creator A table of information describing the creator of the asset (see following lines) string Creator.CreatorType Either User or Group number Creator.CreatorTargetId The ID of the creator user or group string Creator.Name The name/username of the creator number Creator.Id (Use CreatorTargetId instead) - - - number AssetId If InfoType was Asset, this is the ID of the given asset. number AssetTypeId The type of asset (e.g. place, model, shirt)* boolean IsForSale Describes whether the asset is purchasable boolean IsLimited Describes whether the asset is a \"limited item\" that is no longer (if ever) sold boolean IsLimitedUnique Describes whether the asset is a \"limited unique\" (\"Limited U\") item that only has a fixed number sold boolean IsNew Describes whether the asset is marked as \"new\" in the catalog number Remaining The remaining number of items a limited unique item may be sold number Sales The number of items the asset has been sold - - - number ProductId If the InfoType was Product, this is the product ID number IconImageAssetId For developer products and gamepasses, this is the asset ID of the product's icon (or 0 if the product does not have one) - - - boolean IsOwned Whether or not the specified player (if any) owns the item if it's a gamepass.","title":"GetProductInfo"},{"location":"api/getProductInfo/#example","text":"local passID=1234 local player=game.Players.LocalPlayer local info=GetProductInfo(passID,Enum.InfoType.GamePass,player) print(info.Name,info.IsOwned) --prints the name of the game pass and whether or not the player owns it","title":"Example"},{"location":"api/getProductInfo/#parameters","text":"Type Name Description number assetID The ID of the asset to get the information of. InfoType infoType The type of asset to get the info of. Player [player] The player to check ownership info of.","title":"Parameters"},{"location":"api/getProductInfo/#returns","text":"Type Name Description string Name The name shown on the asset's page string Description The description as shown on the asset's page; can be nil if blank number PriceInRobux The cost of purchasing the asset using Robux timestamp Created Timestamp of when the asset was created, e.g. 2018-08-01T17:55:11.98Z timestamp Updated Timestamp of when the asset was last updated by its creator, e.g. 2018-08-01T17:55:11.98Z number ContentRatingTypeId Indicates whether the item is marked as 13+ in catalog number MinimumMembershipLevel The minimum subscription level necessary to purchase the item boolean IsPublicDomain Describes whether the asset can be taken for free - - - Creator Creator A table of information describing the creator of the asset (see following lines) string Creator.CreatorType Either User or Group number Creator.CreatorTargetId The ID of the creator user or group string Creator.Name The name/username of the creator number Creator.Id (Use CreatorTargetId instead) - - - number AssetId If InfoType was Asset, this is the ID of the given asset. number AssetTypeId The type of asset (e.g. place, model, shirt)* boolean IsForSale Describes whether the asset is purchasable boolean IsLimited Describes whether the asset is a \"limited item\" that is no longer (if ever) sold boolean IsLimitedUnique Describes whether the asset is a \"limited unique\" (\"Limited U\") item that only has a fixed number sold boolean IsNew Describes whether the asset is marked as \"new\" in the catalog number Remaining The remaining number of items a limited unique item may be sold number Sales The number of items the asset has been sold - - - number ProductId If the InfoType was Product, this is the product ID number IconImageAssetId For developer products and gamepasses, this is the asset ID of the product's icon (or 0 if the product does not have one) - - - boolean IsOwned Whether or not the specified player (if any) owns the item if it's a gamepass.","title":"Returns"},{"location":"api/instance/","text":"The Instance global has been modified to support a unique creation method that accepts a table of properties, along with specific additions to always assign the Parent last for performance reasons. Simply passing in a classname will automatically use the classic constructor. Constructor Return Function Description Instance Instance.new(Dictionary properties) Creates a new instance with the listed properties. A ClassName must be specified. Instance Instance.new(string className[, Instance parent]) Creates a new instance using the provided ClassName , applying the provided Parent if provided. Example local newInstance=Instance.new({ ClassName=\"Part\"; CFrame=CFrame.new(0,10,0); BrickColor=BrickColor.new(\"Really red\"); Parent=workspace; }) -- OR local oldInstance=Instance.new(\"Part\",workspace)","title":"Instance"},{"location":"api/instance/#constructor","text":"Return Function Description Instance Instance.new(Dictionary properties) Creates a new instance with the listed properties. A ClassName must be specified. Instance Instance.new(string className[, Instance parent]) Creates a new instance using the provided ClassName , applying the provided Parent if provided.","title":"Constructor"},{"location":"api/instance/#example","text":"local newInstance=Instance.new({ ClassName=\"Part\"; CFrame=CFrame.new(0,10,0); BrickColor=BrickColor.new(\"Really red\"); Parent=workspace; }) -- OR local oldInstance=Instance.new(\"Part\",workspace)","title":"Example"},{"location":"api/leakyBucket/","text":"A LeakyBucket is a class containing a number that slowly decreases to 0. It is useful for things like rate limits. Constructor Return Function Description LeakyBucket LeakyBucket.new([number start=0,number rate=1]) Creates a new LeakyBucket starting at the specified start point, decreasing by 1 every time rate passes in seconds. Properties Type Name Description number Bucket The current amount in the bucket. number Rate How often the bucket is decreased. Functions Return Function Description void Add([number amount=1]) Adds the specified amount to the bucket. void Clear([number to=0]) Empties the bucket to the specified level. void Destroy() Destroys the bucket.","title":"LeakyBucket"},{"location":"api/leakyBucket/#constructor","text":"Return Function Description LeakyBucket LeakyBucket.new([number start=0,number rate=1]) Creates a new LeakyBucket starting at the specified start point, decreasing by 1 every time rate passes in seconds.","title":"Constructor"},{"location":"api/leakyBucket/#properties","text":"Type Name Description number Bucket The current amount in the bucket. number Rate How often the bucket is decreased.","title":"Properties"},{"location":"api/leakyBucket/#functions","text":"Return Function Description void Add([number amount=1]) Adds the specified amount to the bucket. void Clear([number to=0]) Empties the bucket to the specified level. void Destroy() Destroys the bucket.","title":"Functions"},{"location":"api/prettyNumber/","text":"PrettyNumber is a function that will format a number to include commas separating the thousands. It's definitely just stolen from the internet . Example local formatted=PrettyNumber(12000000) --returns string \"12,000,000\" Parameters Type Name Description string/number number The number to add commas to. Returns Type Description string The formatted number.","title":"PrettyNumber"},{"location":"api/prettyNumber/#example","text":"local formatted=PrettyNumber(12000000) --returns string \"12,000,000\"","title":"Example"},{"location":"api/prettyNumber/#parameters","text":"Type Name Description string/number number The number to add commas to.","title":"Parameters"},{"location":"api/prettyNumber/#returns","text":"Type Description string The formatted number.","title":"Returns"},{"location":"api/products/","text":"Products is a dictionary of various game passes and developer products for the game to use depending on the game's place ID. Configuration The script contains a dictionary named Places which holds a place ID. The name accompanying the place ID should match the name of the dictionary within the Products dictionary. By default, two places are supported (\"Main\" and \"Dev\"), but it is easy to add more. If the current place's ID is not specified anywhere, the module will return all products across all places.","title":"Products"},{"location":"api/products/#configuration","text":"The script contains a dictionary named Places which holds a place ID. The name accompanying the place ID should match the name of the dictionary within the Products dictionary. By default, two places are supported (\"Main\" and \"Dev\"), but it is easy to add more. If the current place's ID is not specified anywhere, the module will return all products across all places.","title":"Configuration"},{"location":"api/promotedAccounts/","text":"PromotedAccounts is a dictionary of various social media accounts to call players to check out or follow. Sites Site Name Format Twitter \"@NAME\" YouTube \"NAME\" Roblox \"NAME\"","title":"PromotedAccounts"},{"location":"api/promotedAccounts/#sites","text":"Site Name Format Twitter \"@NAME\" YouTube \"NAME\" Roblox \"NAME\"","title":"Sites"},{"location":"api/remote/","text":"Remote is a function used to easily get a remote by the specified name. The script automatically detects all remotes by finding instances with a specific tag (by default, \"Remote\", but can be changed within the script). The framework has a specific organization for remotes where a \"remote\" is actually a folder with the remote name containing any combination of the four remote types ( BindableFunction , BindableEvent , RemoteFunction , RemoteEvent ). Example local myRemote=Remote(\"MyRemote\") --returns the folder by the name of \"MyRemote\" Parameters Type Name Description string remoteName The name of the remote to return. Returns Type Description Instance The remote with the specified name, or nil if there is no remote by that name.","title":"Remote"},{"location":"api/remote/#example","text":"local myRemote=Remote(\"MyRemote\") --returns the folder by the name of \"MyRemote\"","title":"Example"},{"location":"api/remote/#parameters","text":"Type Name Description string remoteName The name of the remote to return.","title":"Parameters"},{"location":"api/remote/#returns","text":"Type Description Instance The remote with the specified name, or nil if there is no remote by that name.","title":"Returns"},{"location":"api/require/","text":"Require is an advanced version of require which accepts a module name instead of a path. If the argument provided is not a string, it will instead treat it as a path and return the result of the regular require function. Example local myModule=Require(\"MyModule\") Parameters Type Name Description string moduleName The name of the module to require. Returns Type Description Variant The result of the module required.","title":"Require"},{"location":"api/require/#example","text":"local myModule=Require(\"MyModule\")","title":"Example"},{"location":"api/require/#parameters","text":"Type Name Description string moduleName The name of the module to require.","title":"Parameters"},{"location":"api/require/#returns","text":"Type Description Variant The result of the module required.","title":"Returns"},{"location":"api/round/","text":"Round is a function that will round the provided number to the nearest multiple (to) or nearest whole number. Example local toThousands=Round(12345678.9,1000) --returns number 12346000 local toWhole=Round(5.2945) --returns number 5 Parameters Type Name Description number number The number to round. number [denominator=1] The multiple to round to. Returns Type Description number The rounded number.","title":"Round"},{"location":"api/round/#example","text":"local toThousands=Round(12345678.9,1000) --returns number 12346000 local toWhole=Round(5.2945) --returns number 5","title":"Example"},{"location":"api/round/#parameters","text":"Type Name Description number number The number to round. number [denominator=1] The multiple to round to.","title":"Parameters"},{"location":"api/round/#returns","text":"Type Description number The rounded number.","title":"Returns"},{"location":"api/search/","text":"Search is a function that searches the given path for the first instance with properties matching all of the criteria specified, or nil if no matches can be found. Example local requirements={Name=\"MyThing\",ClassName=\"Part\"} local part=Search(workspace,requirements) --returns the first part in Workspace named \"MyThing\" Parameters Type Name Description Instance path The path to search the contents of. Dictionary parameters The property values to check. Returns Type Description Instance The result of the search, or nil if unsuccessful.","title":"Search"},{"location":"api/search/#example","text":"local requirements={Name=\"MyThing\",ClassName=\"Part\"} local part=Search(workspace,requirements) --returns the first part in Workspace named \"MyThing\"","title":"Example"},{"location":"api/search/#parameters","text":"Type Name Description Instance path The path to search the contents of. Dictionary parameters The property values to check.","title":"Parameters"},{"location":"api/search/#returns","text":"Type Description Instance The result of the search, or nil if unsuccessful.","title":"Returns"},{"location":"api/waitForPath/","text":"WaitForPath is a function that eliminates the need for long strings of WaitForChild by simply accepting a starting point and a path. Example local player=game.Players.LocalPlayer local gui=WaitForPath(player,\"PlayerGui.ScreenGui.Frame.TextButton\") Parameters Type Name Description Instance target The point to start waiting from. string path The path to wait for, with periods (.) separating each instance name. number [maxWait] The maximum amount of time to wait for the items to load. Returns Type Description Instance The result of the waiting period, or nil if unsuccessful.","title":"WaitForPath"},{"location":"api/waitForPath/#example","text":"local player=game.Players.LocalPlayer local gui=WaitForPath(player,\"PlayerGui.ScreenGui.Frame.TextButton\")","title":"Example"},{"location":"api/waitForPath/#parameters","text":"Type Name Description Instance target The point to start waiting from. string path The path to wait for, with periods (.) separating each instance name. number [maxWait] The maximum amount of time to wait for the items to load.","title":"Parameters"},{"location":"api/waitForPath/#returns","text":"Type Description Instance The result of the waiting period, or nil if unsuccessful.","title":"Returns"}]}