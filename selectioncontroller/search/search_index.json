{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Get TextBox Selections More Easily With the recent introduction of SelectionStart and CursorPosition , it is now possible to read a user's text selection! However, with just these two properties to work from, getting the actual selected text is a bit of a puzzle. Fortunately, the puzzle has already been solved for you with SelectionController! In addition to easily calculating the user's selection, you'll also have access to a custom SelectionChanged event that fires every time a user modifies their selection. Get It Here The SelectionController module is available on Roblox as a model at this link: https://www.roblox.com/library/3651742474/SelectionController-for-Textboxes Installation When importing the module into Roblox Studio, it should be in a location accessible by the client, such as ReplicatedStorage or StarterPlayerScripts: Once imported, the module can be easily accessed by a LocalScript with the require() function: local SelectionController=require(game.ReplicatedStorage.SelectionController) For an extended example of usage, check out the API page . Contributors List of Contributors Created by ChipioIndustries Did you find a bug? Have a feature request? Let it be known and get your name added to the Contributors list! Also, there may or may not be a reward for discovery of bugs...","title":"About"},{"location":"#get-textbox-selections-more-easily","text":"With the recent introduction of SelectionStart and CursorPosition , it is now possible to read a user's text selection! However, with just these two properties to work from, getting the actual selected text is a bit of a puzzle. Fortunately, the puzzle has already been solved for you with SelectionController! In addition to easily calculating the user's selection, you'll also have access to a custom SelectionChanged event that fires every time a user modifies their selection.","title":"Get TextBox Selections More Easily"},{"location":"#get-it-here","text":"The SelectionController module is available on Roblox as a model at this link: https://www.roblox.com/library/3651742474/SelectionController-for-Textboxes","title":"Get It Here"},{"location":"#installation","text":"When importing the module into Roblox Studio, it should be in a location accessible by the client, such as ReplicatedStorage or StarterPlayerScripts: Once imported, the module can be easily accessed by a LocalScript with the require() function: local SelectionController=require(game.ReplicatedStorage.SelectionController) For an extended example of usage, check out the API page .","title":"Installation"},{"location":"#contributors","text":"List of Contributors Created by ChipioIndustries Did you find a bug? Have a feature request? Let it be known and get your name added to the Contributors list! Also, there may or may not be a reward for discovery of bugs...","title":"Contributors"},{"location":"api/","text":"Constructor Return Function Description SelectionController new(TextBox textBox) Create a new SelectionController object wrapped around the provided TextBox. Functions Return Function Description string GetSelection() Get the currently selected text. Will return an empty string if there is no selection or if the TextBox no longer exists. Events Type Function Description Event SelectionChanged(string selection) Fires every time the selected text changes. Example This example assumes that the SelectionController module is located in ReplicatedStorage and the script is inside of the TextBox. local SelectionController=require(game.ReplicatedStorage.SelectionController) --get the module local textBox=script.Parent --get the TextBox local controller=SelectionController.new(textBox) --create a new controller around the TextBox print(controller:GetSelection()) --print the current selection (which will be a blank string, --since there won't be a selection when the game starts) function selectionChanged(to) --print anything passed to the function print(to) end controller.SelectionChanged:Connect(selectionChanged) --connect the selectionChanged function --to the event Secret developer documentation...","title":"API"},{"location":"api/#constructor","text":"Return Function Description SelectionController new(TextBox textBox) Create a new SelectionController object wrapped around the provided TextBox.","title":"Constructor"},{"location":"api/#functions","text":"Return Function Description string GetSelection() Get the currently selected text. Will return an empty string if there is no selection or if the TextBox no longer exists.","title":"Functions"},{"location":"api/#events","text":"Type Function Description Event SelectionChanged(string selection) Fires every time the selected text changes.","title":"Events"},{"location":"api/#example","text":"This example assumes that the SelectionController module is located in ReplicatedStorage and the script is inside of the TextBox. local SelectionController=require(game.ReplicatedStorage.SelectionController) --get the module local textBox=script.Parent --get the TextBox local controller=SelectionController.new(textBox) --create a new controller around the TextBox print(controller:GetSelection()) --print the current selection (which will be a blank string, --since there won't be a selection when the game starts) function selectionChanged(to) --print anything passed to the function print(to) end controller.SelectionChanged:Connect(selectionChanged) --connect the selectionChanged function --to the event Secret developer documentation...","title":"Example"},{"location":"changelog/","text":"8/14/2019 // v1 // Initial Launch Fixed a bug where getting the selection would include an extra character at the end. That fix also accidentally fixed a Roblox bug where SelectionStart would jump to the cursor position and then back when repositioning the cursor, double-firing the SelectionChanged event. Finished documentation.","title":"Changelog"},{"location":"changelog/#8142019-v1-initial-launch","text":"Fixed a bug where getting the selection would include an extra character at the end. That fix also accidentally fixed a Roblox bug where SelectionStart would jump to the cursor position and then back when repositioning the cursor, double-firing the SelectionChanged event. Finished documentation.","title":"8/14/2019 // v1 // Initial Launch"},{"location":"dev-api/","text":"Wait, how'd you get in here? Whatever, just don't make a mess. SelectionController The main module, obviously. Holds most of the main stuff. The SelectionChanged event isn't added to the self table until the metatable has been assigned, since the event constructor requires the controller to access the TextBox and use the GetSelection() function. GetSelection() is the meat of the program, and actually relatively small compared to all the rest of the logic. As long as the start and the end of the selection (defined by SelectionStart and CursorPosition) aren't negative (an indicator that there's no current selection), the numbers will be sorted into ascending order (which string.sub requires) with 1 being subtracted from the larger number (again, compensation for string.sub ). If all is well, the shortened string is returned. Constructor Return Function Description SelectionController new(TextBox textBox) Create a new SelectionController object wrapped around the provided TextBox. Properties Type Property Description TextBox _textBox The textbox wrapped by the SelectionController. Functions Return Function Description string GetSelection() Get the currently selected text. Will return an empty string if there is no selection or if the TextBox no longer exists. Events Type Function Description Event SelectionChanged(string selection) Fires every time the selected text changes. SelectionChanged The table containing all of the event functionality. The biggest nest of code in the system, honestly. The constructor will automatically begin detecting changes and attempting to fire the newly created event. This is primarily done when Text , CursorPosition , or SelectionStart are changed. The Fire() function requires that the provided selection is different from the previous selection, in order to prevent accidental spamming of the event. If so, it will loop through the _functions table and call all of the functions in sequence. It would probably be a good idea to wrap the functions up in a pcall or spawn method to prevent erroring or yeilding functions from breaking the entire script. Constructor Return Function Description Event new(SelectionController controller) Create a new SelectionChanged event and begin listening for changes. Properties Type Property Description dictionary _functions A list of functions attached to the event. string _lastResult The most recent result from GetSelection() . Functions Return Function Description void Fire(string selection) Fire the event if the provided selection was different from the previous selection (_lastResult). EventConnection Connect(function function) Add the given function to a list of functions to be called when the event is fired. EventConnection Designed to help SelectionChanged act like an actual event, EventConnection allows new connections to be disconnected if needed. The Disconnect() function works by locating the _functions table in _event and removing any function with the corresponding function ID. Constructor Return Function Description EventConnection new(SelectionChanged event, string funcID) Create a new EventConnection for the given SelectionChanged event with the given function ID. Properties Type Property Description SelectionChanged _event The event the connection is connected to. string _funcID The ID of the function connected to the event. Functions Return Function Description void Disconnect() Disconnect the connected function from the event.","title":"Dev api"},{"location":"dev-api/#selectioncontroller","text":"The main module, obviously. Holds most of the main stuff. The SelectionChanged event isn't added to the self table until the metatable has been assigned, since the event constructor requires the controller to access the TextBox and use the GetSelection() function. GetSelection() is the meat of the program, and actually relatively small compared to all the rest of the logic. As long as the start and the end of the selection (defined by SelectionStart and CursorPosition) aren't negative (an indicator that there's no current selection), the numbers will be sorted into ascending order (which string.sub requires) with 1 being subtracted from the larger number (again, compensation for string.sub ). If all is well, the shortened string is returned.","title":"SelectionController"},{"location":"dev-api/#constructor","text":"Return Function Description SelectionController new(TextBox textBox) Create a new SelectionController object wrapped around the provided TextBox.","title":"Constructor"},{"location":"dev-api/#properties","text":"Type Property Description TextBox _textBox The textbox wrapped by the SelectionController.","title":"Properties"},{"location":"dev-api/#functions","text":"Return Function Description string GetSelection() Get the currently selected text. Will return an empty string if there is no selection or if the TextBox no longer exists.","title":"Functions"},{"location":"dev-api/#events","text":"Type Function Description Event SelectionChanged(string selection) Fires every time the selected text changes.","title":"Events"},{"location":"dev-api/#selectionchanged","text":"The table containing all of the event functionality. The biggest nest of code in the system, honestly. The constructor will automatically begin detecting changes and attempting to fire the newly created event. This is primarily done when Text , CursorPosition , or SelectionStart are changed. The Fire() function requires that the provided selection is different from the previous selection, in order to prevent accidental spamming of the event. If so, it will loop through the _functions table and call all of the functions in sequence. It would probably be a good idea to wrap the functions up in a pcall or spawn method to prevent erroring or yeilding functions from breaking the entire script.","title":"SelectionChanged"},{"location":"dev-api/#constructor_1","text":"Return Function Description Event new(SelectionController controller) Create a new SelectionChanged event and begin listening for changes.","title":"Constructor"},{"location":"dev-api/#properties_1","text":"Type Property Description dictionary _functions A list of functions attached to the event. string _lastResult The most recent result from GetSelection() .","title":"Properties"},{"location":"dev-api/#functions_1","text":"Return Function Description void Fire(string selection) Fire the event if the provided selection was different from the previous selection (_lastResult). EventConnection Connect(function function) Add the given function to a list of functions to be called when the event is fired.","title":"Functions"},{"location":"dev-api/#eventconnection","text":"Designed to help SelectionChanged act like an actual event, EventConnection allows new connections to be disconnected if needed. The Disconnect() function works by locating the _functions table in _event and removing any function with the corresponding function ID.","title":"EventConnection"},{"location":"dev-api/#constructor_2","text":"Return Function Description EventConnection new(SelectionChanged event, string funcID) Create a new EventConnection for the given SelectionChanged event with the given function ID.","title":"Constructor"},{"location":"dev-api/#properties_2","text":"Type Property Description SelectionChanged _event The event the connection is connected to. string _funcID The ID of the function connected to the event.","title":"Properties"},{"location":"dev-api/#functions_2","text":"Return Function Description void Disconnect() Disconnect the connected function from the event.","title":"Functions"}]}